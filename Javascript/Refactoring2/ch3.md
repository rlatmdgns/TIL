# ch3

## 기이한 이름

- 코드는 단순하고 명료하게 작성한다.
    - - 함수, 모듈, 변수 등, 이름만 보고도 각각 무슨 일을 어떻게 사용하고 있는지 알 수 있어야한다.
- 이름만 잘 지어도 문제 파악시간 절약.
- 마땅한 이름이 떠오르지 않는다면 설계에 근본적인 문제가 숨어 있을 가능성이 높음.

## 중복코드

- 코도가 중복되면 각각을 볼  때마다 서로 차이점은 없는지  주의 깊게 살펴봐야하는 부담이 생김. 
중복 코드, 함수로 추출
- 비슷하지만 똑같지 않다면, 문장 슬라이드하여 한 곳에 모아 함수 추출가능한지 판단.
- 부모로 부터 파생된 서블 클래스에 중복 코드가 있다면, 상위로 메서드 올리기

## 긴 함수

> 오랜 기간 잘 활용되는 프로그램들은 하나 같이 짧은 함수로 구성됐다. - 경험 베이스 ?
> 

이전에는 짧은 함수는 비용이 커서 꺼려하였다.

- 짧은 함수는 이해, 공유, 선택하기가 쉽다.
- 이름을 잘지어두면 본문 코드를 볼 필요성이 적어짐
- 함수가 매개변수, 임시 변수를 많이 사용하면 함수 추출에 방해가된다.
- 코드가 단 한줄이어도 설명이 필요할 시 추출한다.
- 조건문의 case 본문을 함수 호출 문 하나로 바꾼다.
- 반복문도 독립된 함수로 만들자

## 긴 매개변수 목록

- 종종 다른 매개변수에서 값을 얻어 올 수 있다 , 매개변수를 질의 함수로 바꾸기
- 사용 중인 데이터 구조에서 값들을 뽑아 각각 별개의 배개변수로 전달하는 코드라면, **객체 통째로 넘긴다.**
- 항상 함께 전달되는 매개변수들은 객체로 묶어보낸다.
- 함수의 동작 방식을 정하는 플래그 역할의 매개변수는 플래그 인수제거하기로 없애준다.
- 클래스는 매개변수 목록을 줄이는데 효과적

## 전역 데이터

> 전역 데이터를 캡슐화하는 편이 소프트웨어가 진화하는 데 따른 변화에 대처할 수 있다
함수들을 클래스나 모듈에 집어놓고 그안에서 만 사용할 수 있도록 접근 범위를 최소로 줄이는게 좋다.
> 

## 가변 데이터

- 변수 캡슐화
- 하나의 변수 용도가 다른 값들을 저장하는라 값을 갱신하는 경우라면 **변수쪼개기**
- 갱신 로직은 다른코드와 떨어뜨려 놓는 것이 좋다.
- 데이터 담고 있는 변수라면 참조 값을 바꾼다. (구조체를 통째로 교체)

## 뒤엉킨 변경

단일 책임 원칙이 제대로 지켜지지 않을 때 나타난다.

## 산탄총 수술

코드를 변경할 때마다 자잘하게 수정해야하는 클래스가 많을 때.

## 기능 편애

흔히 어떤함수가 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호작용 할 일이 더 많을 때 

- 독립 함수로 추출 후 원하는 모듈로 보내준다.

## 데이터 뭉치

- 몰려다니는 데이터들은 클래스 추출하기로 하나의 객체로 묶는다.

## 반복되는 switch문

> 문제가 되는 이유는 조건절을 하나 추가할 때마다 다른 switch문들도 모두 찾아서 함께 수정해야 하기 때문이다. 이럴때 다형성을 이용하자
> 

## 주석

<aside>
💡 주석을 남겨야겠다는 생각이 들면, 가장 먼저 주석이 필요 없는 코드로 리팩터링한다.

</aside>